---
title: "Longitudinal Statistical Analysis (Anonymized)"
author: ""
output:
  html_document:
    toc: yes
    toc_float: yes
    number_sections: no
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.align="center",fig.pos = "H", out.extra = "",message = FALSE,warning=F,comment = "",tidy.opts=list(width.cutoff=60),tidy=TRUE,echo = F,cache = F)

library(Hmisc)
library(gdata)
library(kableExtra)
library(compareGroups)
library(ggpubr)
library(gam)
library(tinytex)
library(geometry)
library(formatR)
library(ggplot2)
library(nortest)
library(car)
library(gridExtra)
library(ggfortify)
library(reshape)
library(broom)
library(faraway)
library(tidyverse)
library(pwr)
library(naniar)
library(jtools)
library(ggpubr)
library(agricolae)
library(olsrr)
library(lmtest)
library(ggeffects)
library(DHARMa)
library(parameters)
library(huxtable)
library(ggsci)
library(ggprism)
library(patchwork)
library(rstatix)
library(ggrepel)

#Especificos para analisis long
library(nlmeU)
library(lattice)
library(nlme)
library(emmeans)
library(rcompanion)
library(pgirmess)
```


```{r}
rm(list=ls())
data=read.csv('anifro_6m2.csv')
```

```{r,results='hide'}
str(data)
```



```{r, results='hide'}
#### MAKING DATA (sin incluir variables de análisis de seguridad) ####

## Hago la suma de FAMEsc en el seguimiento en el df original para mayor facilidad
data$FAMEsc_total_3m<-data$fame_sc_seg___1+data$fame_sc_seg___2+data$fame_sc_seg___3+data$fame_sc_seg___4+data$fame_sc_seg___5+
  data$fame_sc_seg___6+data$fame_sc_seg___7+data$fame_sc_seg___8

## si en brote_seg (variable si/no que abre desplegable para numero de brotes) hay un 0 poner 0 en numero_brotes_seg
data$numero_brotes_seg <- ifelse(data$brote_seg == 0, 0, data$numero_brotes_seg)

## cambiar character a numeric
data$dosis_cortis<-as.numeric(data$dosis_cortis)
data$sledas<-as.numeric(data$sledas)
data$numero_brotes<-as.numeric(data$numero_brotes)
data$numero_fame_sc_previos<-as.numeric(data$numero_fame_sc_previos)

## Asigno un 0 (=No) al tiempo baseline de las variables respuesta medico, 20, 50 y serologica
respuestas<-c("respuesta_criterio_medico","respuesta_20","respuesta_50","respuesta_serologica")
for (i in respuestas){
  data[[i]] <- ifelse(data$redcap_event_name == "visita_basal_arm_1", 0, data[[i]])
}

## Crear un nuevo df con las variables que si estan en formato long en el df original + añadir las que no y fusionarlas 

long <- data %>%
  select(
    id,                      # Mantener el nombre original
    Event=redcap_event_name,       # Renombrar "nuevo nombre"="variable original" 
    anti_dsDNA=valor_antids_dna,
    CRP=pcr,
    sledai_basal,
    sledai_calculado,
    SLEDAS=sledas,
    PGA=pga_medico,
    PRA=respuesta_criterio_medico, #PRA=physician response assessment
    Response20=respuesta_20,
    Response50=respuesta_50,
    Serological_response=respuesta_serologica,
    remision_doris2021,       #a partir de aqui no estan en formato long, estan partidas en baseline/3+6m
    remision_doris2021_seg,
    lldas,
    lldas_seg,
    numero_brotes,
    numero_brotes_seg,
    numero_fame_sc_previos,
    FAMEsc_total_3m,
    cortis,
    cortis_seg,
    dosis_cortis,
    dosis_cortis_seg
    ) %>%
  mutate(                    # Fusionar variables con info en dos columnas en una
    SLEDAI=coalesce(sledai_basal,sledai_calculado),
    DORIS=coalesce(remision_doris2021,remision_doris2021_seg),
    LLDAS=coalesce(lldas,lldas_seg),
    Flares=coalesce(numero_brotes,numero_brotes_seg),
    csDMARDs=coalesce(numero_fame_sc_previos,FAMEsc_total_3m),
    Corticosteroids=coalesce(cortis,cortis_seg),
    Corticosteroids_dose=coalesce(dosis_cortis,dosis_cortis_seg)
  ) %>%
  select(id,Event,anti_dsDNA,CRP,SLEDAS,PGA,SLEDAI,DORIS,LLDAS,Flares,csDMARDs,Corticosteroids,Corticosteroids_dose,PRA,Response20,
         Response50,Serological_response) 


## Setting factors
long$Event = factor(long$Event,c("visita_basal_arm_1","visita_3_meses_arm_1","visita_6_meses_arm_1"),c("Baseline","3 months","6 months"))
data$redcap_event_name = factor(data$redcap_event_name,c("visita_basal_arm_1","visita_3_meses_arm_1","visita_6_meses_arm_1"),c("Baseline","3 months","6 months"))

factors<-c("DORIS","LLDAS","Corticosteroids","PRA","Response20",
         "Response50","Serological_response")

for (i in factors){
  long[,i]<-factor(long[,i],c("0","1"),c("No","Yes"))
}

```


<br>

## 1. Descriptivos

<br>

### 1.1. Pérdida de seguimiento

<br>

Numero de pacientes en cada tiempo:

```{r}
long %>%
  group_by(Event) %>%                  # Agrupar por tiempo
  summarise(
    num_patients = n_distinct(id)     # Contar pacientes únicos por tiempo
  )
```

<br>

Nos quedamos solo con los pacientes que tengan los 3 tiempos y contamos los NA por cada variable 

```{r}
long3t <- long %>%
  group_by(id) %>%                              # Agrupar por paciente (id)
  filter(n_distinct(Event) == 3) %>%             # Mantener solo pacientes con 3 tiempos
  ungroup() %>%                                  # Desagrupar para un data frame limpio
  as.data.frame(.)                               
```

```{r}
long3t %>%
  group_by(Event) %>%                             # Agrupar por el tiempo (baseline, 3m, 6m)
  summarise(across(-id, ~ sum(is.na(.)), .names = "{col}")) #Contar los NAs de todas menos de id
```

<br>

### 1.2. Distribuciones de las variables

<br>

```{r,results='hide'}
str(long3t)
describe(long3t) #Eliminar punto 2025UI en anti-dsDNA
long3t$anti_dsDNA[long3t$anti_dsDNA>2000]<-NA
```


```{r,fig.dim=c(10,9)}

numericas<-names(Filter(function(x) is.numeric(x) || is.integer(x), long3t))
numericas <- c(numericas, "Event")

ggplot(melt(long3t[, numericas]), aes(x = value, fill = as.factor(Event))) +
  geom_histogram(aes(y = ..density..), color = "black", bins = 30, alpha = 0.5, position = "identity") +  # Histogramas superpuestos
  geom_density(color = "black", size = 0.7, aes(group = Event)) +  # Densidad para cada Event
  facet_wrap(~variable, scales = "free") +  # Facetas por variable, sin que se repita por Event
  scale_fill_manual(values = c("red", "blue", "green")) +  # Colores para cada Event
  labs(x = "", y = "Density", fill = "Evento")+
  theme(legend.position = "top")


```

<br>

## 2. Análisis longitudinal

<br>

- Existen 2 tipos de variables a analizar: variables numéricas continuas y discretas con una distribución alejada de la normalidad y variables categóricas binarias.  
- El análisis estadístico se realizará con tests estadísticos tradicionales para muestras pareadas no paramétricos y pruebas posthoc. Para las variables numéricas tanto continuas como discretas se usará un Test de Friedman (alternativa no paramétrica al ANOVA de medidas repetidas) con el ajuste del pvalor por el método de Holm. Para las variables binarias de usará un Cochran´s Q test y posteriormente una comparación múltiple con McNemar's Chi-squared Test con el método de Bonferroni.
- Para cada variables, se seleccionarán para el análisis SOLO LOS PACIENTES CON OBSERVACIONES COMPLETAS EN LOS 3 TIEMPOS.  

<br>

```{r}
wide3t <- long3t %>%           #Convertir el df en formato long a formato wide
  pivot_wider(
    names_from = Event,             # Las nuevas columnas se basarán en los valores de 'Event'
    values_from = -c(id, Event)  # Excluye 'id' y 'Event' de las variables a pivotar
  )
```

```{r}

# Definir función que calcule estadísticos para los 3 tiempos en variables continuas en df wide
continuas_stats <- function(df, id_col, time_var1, time_var2, time_var3) {
  
  # Asegurarse de que las columnas estén en el formato correcto
  df %>%
    # 1. Seleccionar el ID y las 3 variables de tiempo
    select(!!id_col, !!time_var1, !!time_var2, !!time_var3) %>%
    
    # 2. Eliminar filas con NA en alguna de las 3 variables de tiempo
    filter(complete.cases(.)) %>%
    
    # 3. Calcular los estadísticos de cada variable de tiempo
    summarise(
      N_1 = sum(!is.na(!!sym(time_var1))),
      Mean_1 = mean(!!sym(time_var1)),
      Median_1 = median(!!sym(time_var1)),
      SD_1 = sd(!!sym(time_var1)),
      IQR_1 = IQR(!!sym(time_var1)),
      
      N_2 = sum(!is.na(!!sym(time_var2))),
      Mean_2 = mean(!!sym(time_var2)),
      Median_2 = median(!!sym(time_var2)),
      SD_2 = sd(!!sym(time_var2)),
      IQR_2 = IQR(!!sym(time_var2)),
      
      N_3 = sum(!is.na(!!sym(time_var3))),
      Mean_3 = mean(!!sym(time_var3)),
      Median_3 = median(!!sym(time_var3)),
      SD_3 = sd(!!sym(time_var3)),
      IQR_3 = IQR(!!sym(time_var3))
    ) %>%
    
    # 4. Pivotear los resultados para que los tiempos sean columnas y los estadísticos sean filas
    pivot_longer(cols = everything(), 
                 names_to = c("Statistic", "Time"), 
                 names_pattern = "(.*)_(.*)") %>%
    
    # 5. Reorganizar el formato para que las filas sean los estadísticos y las columnas sean los tiempos
    pivot_wider(names_from = Time, values_from = value) %>%
    
    # 6. Asegurarse de que los nombres de las columnas sean limpios y significativos
    rename(Baseline = `1`, `3months` = `2`, `6months` = `3`) %>%
    
    # 7. Redondear los valores numéricos a 2 decimales
    mutate(across(where(is.numeric), round, digits = 1)) 
}


```


### 2.1. Índices de actividad {.tabset}

<br>

#### SLEDAI

<br>

```{r}
continuas_stats(wide3t, "id", "SLEDAI_Baseline", "SLEDAI_3 months", "SLEDAI_6 months")
```

<br>

La variable SLEDAI presenta violaciones de los supuestos de normalidad y homocedasticidad por lo que se utilizará la versión no paramétrica del ANOVA de medidas repetidas, el Test de Friedman. Cuando el test de Friedman es significativo quiere decir que hay diferencias entre los tiempos, pero no especifica entre cuales. Por eso, a continuación se realiza una prueba post-hoc que utiliza la correccion de Holm para el ajuste de los p-valores en comparaciones múltiples y establece entre que tiempo se observan las diferencias. 

```{r}
temp<- wide3t %>%
    select(id,SLEDAI_Baseline,`SLEDAI_3 months`,`SLEDAI_6 months`) %>%
    filter(complete.cases(.))%>% 
  pivot_longer(
    cols = c(SLEDAI_Baseline,`SLEDAI_3 months`,`SLEDAI_6 months`),
    names_to = "Event",  # Nueva columna con los nombres originales
    values_to = "SLEDAI"  # Nueva columna con los valores
  ) %>%
  # Limpiar los nombres de los eventos para mayor consistencia
  mutate(Event = case_when(
    Event == "SLEDAI_Baseline" ~ "Baseline",
    Event == "SLEDAI_3 months" ~ "3 months",
    Event == "SLEDAI_6 months" ~ "6 months",
    TRUE ~ Event
  ))

friedman.test(y=temp$SLEDAI, groups=temp$Event, blocks=temp$id)
friedmanmc(y=temp$SLEDAI, groups=temp$Event, blocks=temp$id) 
```



<br>

```{r, fig.dim=c(8,5)}
ggpaired(temp, x = "Event", y = "SLEDAI",id="id",
         ylab = "SLEDAI", xlab = "",color="black",ggtheme=theme_gray(),point.size=2,line.color = "id",line.size = 0.7)+
  theme(legend.position = "none")
```


#### condition-DAS

<br>

```{r}
continuas_stats(wide3t, "id", "SLEDAS_Baseline", "SLEDAS_3 months", "SLEDAS_6 months")
```

<br>

Lo mismo, se utiliza Test de Friedman y corrección de Holm.

<br>

```{r}
temp<- wide3t %>%
    select(id,SLEDAS_Baseline,`SLEDAS_3 months`,`SLEDAS_6 months`) %>%
    filter(complete.cases(.))%>% 
  pivot_longer(
    cols = c(SLEDAS_Baseline, `SLEDAS_3 months`, `SLEDAS_6 months`),
    names_to = "Event",  # Nueva columna con los nombres originales
    values_to = "SLEDAS"  # Nueva columna con los valores
  ) %>%
  # Limpiar los nombres de los eventos para mayor consistencia
  mutate(Event = case_when(
    Event == "SLEDAS_Baseline" ~ "Baseline",
    Event == "SLEDAS_3 months" ~ "3 months",
    Event == "SLEDAS_6 months" ~ "6 months",
    TRUE ~ Event
  ))

friedman.test(y=temp$SLEDAS, groups=temp$Event, blocks=temp$id)
friedmanmc(y=temp$SLEDAS, groups=temp$Event, blocks=temp$id)  
```


<br>

```{r, fig.dim=c(8,5)}
ggpaired(temp, x = "Event", y = "SLEDAS",id="id",
         ylab = "SLE-DAS", xlab = "",color="black",ggtheme=theme_gray(),point.size=2,line.color = "id",line.size = 0.7)+
  theme(legend.position = "none")
```

<br>

#### VGM

<br>

```{r}
continuas_stats(wide3t, "id", "PGA_Baseline", "PGA_3 months", "PGA_6 months")
```

<br>

Lo mismo, se utiliza Test de Friedman y corrección de Holm.

<br>

```{r}
temp<- wide3t %>%
    select(id,PGA_Baseline,`PGA_3 months`,`PGA_6 months`) %>%
    filter(complete.cases(.))%>% 
  pivot_longer(
    cols = c(PGA_Baseline, `PGA_3 months`, `PGA_6 months`),
    names_to = "Event",  # Nueva columna con los nombres originales
    values_to = "PGA"  # Nueva columna con los valores
  ) %>%
  # Limpiar los nombres de los eventos para mayor consistencia
  mutate(Event = case_when(
    Event == "PGA_Baseline" ~ "Baseline",
    Event == "PGA_3 months" ~ "3 months",
    Event == "PGA_6 months" ~ "6 months",
    TRUE ~ Event
  ))

friedman.test(y=temp$PGA, groups=temp$Event, blocks=temp$id)
friedmanmc(y=temp$PGA, groups=temp$Event, blocks=temp$id)  
```



<br>

```{r, fig.dim=c(8,5)}
ggpaired(temp, x = "Event", y = "PGA",id="id",
         ylab = "PGA", xlab = "",color="black",ggtheme=theme_gray(),point.size=2,line.color = "id",line.size = 0.7)+
  theme(legend.position = "none")
```

<br>

#### SLICC

<br>

En el SLICC es un caso diferente ya que solo hay mediciones en los tiempos baseline y 6 meses.

<br>

```{r}
temp<-data %>%
  select(id,Event=redcap_event_name,slicc_previo,slicc_calculado) %>%
  mutate(SLICC=coalesce(slicc_previo,slicc_calculado)) %>%
  select(id,Event,SLICC) %>%
  pivot_wider(
    names_from = Event,            
    values_from = SLICC  
  ) %>%
  select(-`3 months`)%>%
  filter(complete.cases(.))
```

```{r}
# Definir función que calcule estadísticos para dos tiempos en variables continuas en df wide
continuas_stats_two <- function(df, id_col, time_var1, time_var2) {
  
  # Asegurarse de que las columnas estén en el formato correcto
  df %>%
    # 1. Seleccionar el ID y las 2 variables de tiempo
    select(!!id_col, !!time_var1, !!time_var2) %>%
    
    # 2. Eliminar filas con NA en alguna de las 2 variables de tiempo
    filter(complete.cases(.)) %>%
    
    # 3. Calcular los estadísticos de cada variable de tiempo
    summarise(
      N_1 = sum(!is.na(!!sym(time_var1))),
      Mean_1 = mean(!!sym(time_var1)),
      Median_1 = median(!!sym(time_var1)),
      SD_1 = sd(!!sym(time_var1)),
      IQR_1 = IQR(!!sym(time_var1)),
      
      N_2 = sum(!is.na(!!sym(time_var2))),
      Mean_2 = mean(!!sym(time_var2)),
      Median_2 = median(!!sym(time_var2)),
      SD_2 = sd(!!sym(time_var2)),
      IQR_2 = IQR(!!sym(time_var2))
    ) %>%
    
    # 4. Pivotear los resultados para que los tiempos sean columnas y los estadísticos sean filas
    pivot_longer(cols = everything(), 
                 names_to = c("Statistic", "Time"), 
                 names_pattern = "(.*)_(.*)") %>%
    
    # 5. Reorganizar el formato para que las filas sean los estadísticos y las columnas sean los tiempos
    pivot_wider(names_from = Time, values_from = value) %>%
    
    # 6. Asegurarse de que los nombres de las columnas sean limpios y significativos
    rename(Baseline = `1`, `6 months` = `2`) %>%
    
    # 7. Redondear los valores numéricos a 2 decimales (excepto "N")
    mutate(across(where(is.numeric), round, digits = 1))
}

```


```{r}
continuas_stats_two(temp, "id","Baseline","6 months")
```

<br>

```{r, fig.dim=c(4,3)}
temp<- temp %>% pivot_longer(
    cols = c(Baseline,`6 months`),
    names_to = "Event",  # Nueva columna con los nombres originales
    values_to = "SLICC"  # Nueva columna con los valores
  )

ggplot(temp,aes(x=SLICC))+ geom_histogram(aes(y = ..density..),fill="grey", color="black") + geom_density(color="blue", size=0.7)
```

<br>

Las comparaciones entre los tiempos basal y 6 meses se realizarán con la Prueba de los signos (Sign Test).

<br>

```{r}
temp  %>%
  sign_test(SLICC ~ Event)
```



<br>


```{r, fig.dim=c(8,5)}
ggpaired(temp, x = "Event", y = "SLICC",id="id",
         ylab = "SLICC", xlab = "",color="black",ggtheme=theme_gray(),point.size=2,line.color = "id",line.size = 0.7)+
  theme(legend.position = "none")
```

<br>


### 2.2. Marcadores analíticos de actividad {.tabset}

<br>

#### Anti-dsDNA

<br>

```{r}
continuas_stats(wide3t, "id", "anti_dsDNA_Baseline", "anti_dsDNA_3 months", "anti_dsDNA_6 months")
```

<br>

La distribución de esta variable, aunque es puramente continua, presenta un sesgo muy importante a la izquierda, por lo que el valor de la media y de la mediana difieren mucho. Creo que es mejor reportar la mediana y el IQR ya que son medidas de centralidad y dispersión más verosímiles. También utilizaremos Friedman + Holm.

<br>

```{r}
temp<- wide3t %>%
    select(id,anti_dsDNA_Baseline,`anti_dsDNA_3 months`,`anti_dsDNA_6 months`) %>%
    filter(complete.cases(.))%>% 
  pivot_longer(
    cols = c(anti_dsDNA_Baseline, `anti_dsDNA_3 months`, `anti_dsDNA_6 months`),
    names_to = "Event",  # Nueva columna con los nombres originales
    values_to = "anti_dsDNA"  # Nueva columna con los valores
  ) %>%
  # Limpiar los nombres de los eventos para mayor consistencia
  mutate(Event = case_when(
    Event == "anti_dsDNA_Baseline" ~ "Baseline",
    Event == "anti_dsDNA_3 months" ~ "3 months", 
    Event == "anti_dsDNA_6 months" ~ "6 months",
    TRUE ~ Event
  ))

friedman.test(y=temp$anti_dsDNA, groups=temp$Event, blocks=temp$id)
friedmanmc(y=temp$anti_dsDNA, groups=temp$Event, blocks=temp$id)  
```



<br>

#### PCR

<br>

```{r}
continuas_stats(wide3t, "id", "CRP_Baseline", "CRP_3 months", "CRP_6 months")
```

<br>

Ocurre lo mismo, sesgo a la izquierda. Reportaremos mediana y IQR y utilizaremos Friedman + Holm

<br>

```{r}
temp<- wide3t %>%
    select(id,CRP_Baseline,`CRP_3 months`,`CRP_6 months`) %>%
    filter(complete.cases(.))%>% 
  pivot_longer(
    cols = c(CRP_Baseline, `CRP_3 months`, `CRP_6 months`),
    names_to = "Event",  # Nueva columna con los nombres originales
    values_to = "CRP"  # Nueva columna con los valores
  ) %>%
  # Limpiar los nombres de los eventos para mayor consistencia
  mutate(Event = case_when(
    Event == "CRP_Baseline" ~ "Baseline",
    Event == "CRP_3 months" ~ "3 months", 
    Event == "CRP_6 months" ~ "6 months",
    TRUE ~ Event
  ))

friedman.test(y=temp$CRP, groups=temp$Event, blocks=temp$id)
friedmanmc(y=temp$CRP, groups=temp$Event, blocks=temp$id)  
```



<br>

### 2.3. Índices de remisión {.tabset}

<br>

Para las variables categóricas binarias se utilizará el Cochran’s Q Test y la prueba posthoc con McNemar's Chi-squared Test con la corrección de Bonferroni.

```{r}
# Definir función para variables binarias de tipo factor en tres tiempos
binarias_stats <- function(df, id_col, time_var1, time_var2, time_var3) {
  df %>%
    # Seleccionar el ID y las 3 variables de tiempo
    select(!!id_col, !!time_var1, !!time_var2, !!time_var3) %>%
    
    # Filtrar filas completas (sin NA)
    filter(complete.cases(.)) %>%
    
    # Pivotar al formato largo para facilitar el cálculo
    pivot_longer(cols = c(!!sym(time_var1), !!sym(time_var2), !!sym(time_var3)),
                 names_to = "Time", values_to = "Category") %>%
    
    # Agrupar por tiempo y categoría para el cálculo de estadísticas
    group_by(Time, Category) %>%
    summarise(
      N = n(),  # Número de observaciones por categoría
      .groups = "drop_last"
    ) %>%
    
   # Calcular la proporción
    group_by(Time) %>%
    mutate(
      FR = round(N / sum(N) * 100, 2)  # Proporción en porcentaje
    ) %>%
    ungroup() %>%
    
    # Reorganizar el formato para tener los tiempos como columnas
    pivot_wider(names_from = Time, values_from = c(N, FR)) %>%
    
    # Ordenar las columnas y dejar nombres claros
    select(Category, starts_with("N"), starts_with("FR"))
}



```


#### DORIS


<br>

```{r}

binarias_stats(wide3t,"id","DORIS_Baseline","DORIS_3 months","DORIS_6 months")
```

<br>

```{r}
temp<- wide3t %>%
    select(id,DORIS_Baseline,`DORIS_3 months`,`DORIS_6 months`) %>%
    filter(complete.cases(.))%>% 
  pivot_longer(
    cols = c(DORIS_Baseline, `DORIS_3 months`, `DORIS_6 months`),
    names_to = "Event",  # Nueva columna con los nombres originales
    values_to = "DORIS"  # Nueva columna con los valores
  ) %>%
  # Limpiar los nombres de los eventos para mayor consistencia
  mutate(Event = case_when(
    Event == "DORIS_Baseline" ~ "Baseline",
    Event == "DORIS_3 months" ~ "3 months", 
    Event == "DORIS_6 months" ~ "6 months",
    TRUE ~ Event
  ))

cochran_qtest(DORIS ~ Event | id, data = temp)
pairwise_mcnemar_test(DORIS ~ Event | id, data = temp)
```



<br>

```{r}
doris_pct <- temp %>%
  mutate(Event = factor(Event, levels = c("Baseline", "3 months", "6 months"))) %>%
  group_by(Event, DORIS) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(Event) %>%
  mutate(percentage = count / sum(count) * 100)

ggplot(doris_pct, aes(x = Event, y = count, fill = DORIS)) +
  geom_bar(stat = "identity", position = "stack",width=0.7) +  # Gráfico de barras apiladas
  geom_text(
    aes(label = paste0(round(percentage, 1), "%")),
    position = position_stack(vjust = 0.5),  # Centra las etiquetas en las barras
    color = "black", size = 4              # Ajusta el color y el tamaño del texto
  ) +
  labs(x = "Event", y = "Count", fill = "DORIS") +
  theme_gray()

```


<br>

#### LLDAS

<br>


```{r}

binarias_stats(wide3t,"id","LLDAS_Baseline","LLDAS_3 months","LLDAS_6 months")
```

<br>

```{r}
temp<- wide3t %>%
    select(id,LLDAS_Baseline,`LLDAS_3 months`,`LLDAS_6 months`) %>%
    filter(complete.cases(.))%>% 
  pivot_longer(
    cols = c(LLDAS_Baseline, `LLDAS_3 months`, `LLDAS_6 months`),
    names_to = "Event",  # Nueva columna con los nombres originales
    values_to = "LLDAS"  # Nueva columna con los valores
  ) %>%
  # Limpiar los nombres de los eventos para mayor consistencia
  mutate(Event = case_when(
    Event == "LLDAS_Baseline" ~ "Baseline",
    Event == "LLDAS_3 months" ~ "3 months", 
    Event == "LLDAS_6 months" ~ "6 months",
    TRUE ~ Event
  ))

cochran_qtest(LLDAS ~ Event | id, data = temp)
pairwise_mcnemar_test(LLDAS ~ Event | id, data = temp)
```



<br>

```{r}
LLDAS_pct <- temp %>%
  mutate(Event = factor(Event, levels = c("Baseline", "3 months", "6 months"))) %>%
  group_by(Event, LLDAS) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(Event) %>%
  mutate(percentage = count / sum(count) * 100)

ggplot(LLDAS_pct, aes(x = Event, y = count, fill = LLDAS)) +
  geom_bar(stat = "identity", position = "stack",width=0.7) +  # Gráfico de barras apiladas
  geom_text(
    aes(label = paste0(round(percentage, 1), "%")),
    position = position_stack(vjust = 0.5),  # Centra las etiquetas en las barras
    color = "black", size = 4              # Ajusta el color y el tamaño del texto
  ) +
  labs(x = "Event", y = "Count", fill = "LLDAS") +
  theme_gray()

```


<br>

### 2.4. Tratamiento {.tabset}

<br>

#### Cortis Si[path]

<br>

<br>

```{r}

binarias_stats(wide3t,"id","Corticosteroids_Baseline","Corticosteroids_3 months","Corticosteroids_6 months")
```

<br>

```{r}
temp<- wide3t %>%
    select(id,Corticosteroids_Baseline,`Corticosteroids_3 months`,`Corticosteroids_6 months`) %>%
    filter(complete.cases(.))%>% 
  pivot_longer(
    cols = c(Corticosteroids_Baseline, `Corticosteroids_3 months`, `Corticosteroids_6 months`),
    names_to = "Event",  # Nueva columna con los nombres originales
    values_to = "Corticosteroids"  # Nueva columna con los valores
  ) %>%
  # Limpiar los nombres de los eventos para mayor consistencia
  mutate(Event = case_when(
    Event == "Corticosteroids_Baseline" ~ "Baseline",
    Event == "Corticosteroids_3 months" ~ "3 months", 
    Event == "Corticosteroids_6 months" ~ "6 months",
    TRUE ~ Event
  ))

cochran_qtest(Corticosteroids ~ Event | id, data = temp)
pairwise_mcnemar_test(Corticosteroids ~ Event | id, data = temp)
```



<br>

```{r}
Corticosteroids_pct <- temp %>%
  mutate(Event = factor(Event, levels = c("Baseline", "3 months", "6 months"))) %>%
  group_by(Event, Corticosteroids) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(Event) %>%
  mutate(percentage = count / sum(count) * 100)

ggplot(Corticosteroids_pct, aes(x = Event, y = count, fill = Corticosteroids)) +
  geom_bar(stat = "identity", position = "stack",width=0.7) +  # Gráfico de barras apiladas
  geom_text(
    aes(label = paste0(round(percentage, 1), "%")),
    position = position_stack(vjust = 0.5),  # Centra las etiquetas en las barras
    color = "black", size = 4              # Ajusta el color y el tamaño del texto
  ) +
  labs(x = "Event", y = "Count", fill = "Corticosteroids") +
  theme_gray()

```


<br>

#### Dosis de cortis

<br>

<br>

```{r}
continuas_stats(wide3t, "id", "Corticosteroids_dose_Baseline", "Corticosteroids_dose_3 months", "Corticosteroids_dose_6 months")
```

<br>

```{r}
temp<- wide3t %>%
    select(id,Corticosteroids_dose_Baseline,`Corticosteroids_dose_3 months`,`Corticosteroids_dose_6 months`) %>%
    filter(complete.cases(.))%>% 
  pivot_longer(
    cols = c(Corticosteroids_dose_Baseline,`Corticosteroids_dose_3 months`,`Corticosteroids_dose_6 months`),
    names_to = "Event",  # Nueva columna con los nombres originales
    values_to = "Corticosteroids_dose"  # Nueva columna con los valores
  ) %>%
  # Limpiar los nombres de los eventos para mayor consistencia
  mutate(Event = case_when(
    Event == "Corticosteroids_dose_Baseline" ~ "Baseline",
    Event == "Corticosteroids_dose_3 months" ~ "3 months",
    Event == "Corticosteroids_dose_6 months" ~ "6 months",
    TRUE ~ Event
  ))

friedman.test(y=temp$Corticosteroids_dose, groups=temp$Event, blocks=temp$id)
friedmanmc(y=temp$Corticosteroids_dose, groups=temp$Event, blocks=temp$id) 
```



<br>

#### Número de FAMEsc tomados a la vez

<br>

```{r}
continuas_stats(wide3t, "id", "csDMARDs_Baseline", "csDMARDs_3 months", "csDMARDs_6 months")
```

<br>

```{r}
temp<- wide3t %>%
    select(id,csDMARDs_Baseline,`csDMARDs_3 months`,`csDMARDs_6 months`) %>%
    filter(complete.cases(.))%>% 
  pivot_longer(
    cols = c(csDMARDs_Baseline,`csDMARDs_3 months`,`csDMARDs_6 months`),
    names_to = "Event",  # Nueva columna con los nombres originales
    values_to = "csDMARDs"  # Nueva columna con los valores
  ) %>%
  # Limpiar los nombres de los eventos para mayor consistencia
  mutate(Event = case_when(
    Event == "csDMARDs_Baseline" ~ "Baseline",
    Event == "csDMARDs_3 months" ~ "3 months",
    Event == "csDMARDs_6 months" ~ "6 months",
    TRUE ~ Event
  ))

friedman.test(y=temp$csDMARDs, groups=temp$Event, blocks=temp$id)
friedmanmc(y=temp$csDMARDs, groups=temp$Event, blocks=temp$id) 
```



<br>

```{r, fig.dim=c(8,5)}
ggpaired(temp, x = "Event", y = "csDMARDs",id="id",
         ylab = "Number of csDMARDs", xlab = "",color="black",ggtheme=theme_gray(),point.size=2,line.color = "id",line.size = 0.7)+
  theme(legend.position = "none")
```


### 2.5. Brotes y respuesta {.tabset}

<br>

#### Número de Brotes

<br>

<br>

```{r}
continuas_stats(wide3t, "id", "Flares_Baseline", "Flares_3 months", "Flares_6 months")
```

<br>

```{r}
temp<- wide3t %>%
    select(id,Flares_Baseline,`Flares_3 months`,`Flares_6 months`) %>%
    filter(complete.cases(.))%>% 
  pivot_longer(
    cols = c(Flares_Baseline,`Flares_3 months`,`Flares_6 months`),
    names_to = "Event",  # Nueva columna con los nombres originales
    values_to = "Flares"  # Nueva columna con los valores
  ) %>%
  # Limpiar los nombres de los eventos para mayor consistencia
  mutate(Event = case_when(
    Event == "Flares_Baseline" ~ "Baseline",
    Event == "Flares_3 months" ~ "3 months",
    Event == "Flares_6 months" ~ "6 months",
    TRUE ~ Event
  ))

friedman.test(y=temp$Flares, groups=temp$Event, blocks=temp$id)
friedmanmc(y=temp$Flares, groups=temp$Event, blocks=temp$id) 
```

<br>

```{r, fig.dim=c(8,5)}
ggpaired(temp, x = "Event", y = "Flares",id="id",
         ylab = "Number of flares", xlab = "",color="black",ggtheme=theme_gray(),point.size=2,line.color = "id",line.size = 0.7)+
  theme(legend.position = "none")
```


<br>

#### Respuesta de criterio médico (PRA)



<br>

```{r}

binarias_stats(wide3t,"id","PRA_Baseline","PRA_3 months","PRA_6 months")
```

<br>

```{r}
temp<- wide3t %>%
    select(id,PRA_Baseline,`PRA_3 months`,`PRA_6 months`) %>%
    filter(complete.cases(.))%>% 
  pivot_longer(
    cols = c(PRA_Baseline, `PRA_3 months`, `PRA_6 months`),
    names_to = "Event",  # Nueva columna con los nombres originales
    values_to = "PRA"  # Nueva columna con los valores
  ) %>%
  # Limpiar los nombres de los eventos para mayor consistencia
  mutate(Event = case_when(
    Event == "PRA_Baseline" ~ "Baseline",
    Event == "PRA_3 months" ~ "3 months", 
    Event == "PRA_6 months" ~ "6 months",
    TRUE ~ Event
  ))

cochran_qtest(PRA ~ Event | id, data = temp)
pairwise_mcnemar_test(PRA ~ Event | id, data = temp)
```



<br>

```{r}
PRA_pct <- temp %>%
  mutate(Event = factor(Event, levels = c("Baseline", "3 months", "6 months"))) %>%
  group_by(Event, PRA) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(Event) %>%
  mutate(percentage = count / sum(count) * 100)

ggplot(PRA_pct, aes(x = Event, y = count, fill = PRA)) +
  geom_bar(stat = "identity", position = "stack",width=0.7) +  # Gráfico de barras apiladas
  geom_text(
    aes(label = paste0(round(percentage, 1), "%")),
    position = position_stack(vjust = 0.5),  # Centra las etiquetas en las barras
    color = "black", size = 4              # Ajusta el color y el tamaño del texto
  ) +
  labs(x = "Event", y = "Count", fill = "PRA") +
  theme_gray()

```


<br>

#### Respuesta 20%

<br>

<br>

```{r}

binarias_stats(wide3t,"id","Response20_Baseline","Response20_3 months","Response20_6 months")
```

<br>

```{r}
temp<- wide3t %>%
    select(id,Response20_Baseline,`Response20_3 months`,`Response20_6 months`) %>%
    filter(complete.cases(.))%>% 
  pivot_longer(
    cols = c(Response20_Baseline, `Response20_3 months`, `Response20_6 months`),
    names_to = "Event",  # Nueva columna con los nombres originales
    values_to = "Response20"  # Nueva columna con los valores
  ) %>%
  # Limpiar los nombres de los eventos para mayor consistencia
  mutate(Event = case_when(
    Event == "Response20_Baseline" ~ "Baseline",
    Event == "Response20_3 months" ~ "3 months", 
    Event == "Response20_6 months" ~ "6 months",
    TRUE ~ Event
  ))

cochran_qtest(Response20 ~ Event | id, data = temp)
pairwise_mcnemar_test(Response20 ~ Event | id, data = temp)
```


<br>

```{r}
Response20_pct <- temp %>%
  mutate(Event = factor(Event, levels = c("Baseline", "3 months", "6 months"))) %>%
  group_by(Event, Response20) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(Event) %>%
  mutate(percentage = count / sum(count) * 100)

ggplot(Response20_pct, aes(x = Event, y = count, fill = Response20)) +
  geom_bar(stat = "identity", position = "stack",width=0.7) +  # Gráfico de barras apiladas
  geom_text(
    aes(label = paste0(round(percentage, 1), "%")),
    position = position_stack(vjust = 0.5),  # Centra las etiquetas en las barras
    color = "black", size = 4              # Ajusta el color y el tamaño del texto
  ) +
  labs(x = "Event", y = "Count", fill = "Response 20%") +
  theme_gray()

```


<br>

#### Respuesta 50%

<br>

<br>

```{r}

binarias_stats(wide3t,"id","Response50_Baseline","Response50_3 months","Response50_6 months")
```

<br>

```{r}
temp<- wide3t %>%
    select(id,Response50_Baseline,`Response50_3 months`,`Response50_6 months`) %>%
    filter(complete.cases(.))%>% 
  pivot_longer(
    cols = c(Response50_Baseline, `Response50_3 months`, `Response50_6 months`),
    names_to = "Event",  # Nueva columna con los nombres originales
    values_to = "Response50"  # Nueva columna con los valores
  ) %>%
  # Limpiar los nombres de los eventos para mayor consistencia
  mutate(Event = case_when(
    Event == "Response50_Baseline" ~ "Baseline",
    Event == "Response50_3 months" ~ "3 months", 
    Event == "Response50_6 months" ~ "6 months",
    TRUE ~ Event
  ))

cochran_qtest(Response50 ~ Event | id, data = temp)
pairwise_mcnemar_test(Response50 ~ Event | id, data = temp)
```


<br>

```{r}
Response50_pct <- temp %>%
  mutate(Event = factor(Event, levels = c("Baseline", "3 months", "6 months"))) %>%
  group_by(Event, Response50) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(Event) %>%
  mutate(percentage = count / sum(count) * 100)

ggplot(Response50_pct, aes(x = Event, y = count, fill = Response50)) +
  geom_bar(stat = "identity", position = "stack",width=0.7) +  # Gráfico de barras apiladas
  geom_text(
    aes(label = paste0(round(percentage, 1), "%")),
    position = position_stack(vjust = 0.5),  # Centra las etiquetas en las barras
    color = "black", size = 4              # Ajusta el color y el tamaño del texto
  ) +
  labs(x = "Event", y = "Count", fill = "Response 50%") +
  theme_gray()

```


<br>

#### Respuesta serológica

<br>

```{r}

binarias_stats(wide3t,"id","Serological_response_Baseline","Serological_response_3 months","Serological_response_6 months")
```

<br>

```{r}
temp<- wide3t %>%
    select(id,Serological_response_Baseline,`Serological_response_3 months`,`Serological_response_6 months`) %>%
    filter(complete.cases(.))%>% 
  pivot_longer(
    cols = c(Serological_response_Baseline, `Serological_response_3 months`, `Serological_response_6 months`),
    names_to = "Event",  # Nueva columna con los nombres originales
    values_to = "Serological_response"  # Nueva columna con los valores
  ) %>%
  # Limpiar los nombres de los eventos para mayor consistencia
  mutate(Event = case_when(
    Event == "Serological_response_Baseline" ~ "Baseline",
    Event == "Serological_response_3 months" ~ "3 months", 
    Event == "Serological_response_6 months" ~ "6 months",
    TRUE ~ Event
  ))

cochran_qtest(Serological_response ~ Event | id, data = temp)
pairwise_mcnemar_test(Serological_response ~ Event | id, data = temp)
```


<br>

```{r}
Serological_response_pct <- temp %>%
  mutate(Event = factor(Event, levels = c("Baseline", "3 months", "6 months"))) %>%
  group_by(Event, Serological_response) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(Event) %>%
  mutate(percentage = count / sum(count) * 100)

ggplot(Serological_response_pct, aes(x = Event, y = count, fill = Serological_response)) +
  geom_bar(stat = "identity", position = "stack",width=0.7) +  # Gráfico de barras apiladas
  geom_text(
    aes(label = paste0(round(percentage, 1), "%")),
    position = position_stack(vjust = 0.5),  # Centra las etiquetas en las barras
    color = "black", size = 4              # Ajusta el color y el tamaño del texto
  ) +
  labs(x = "Event", y = "Count", fill = "Serological response") +
  theme_gray()

```


<br>


## 3. Análisis de seguridad {.tabset}

<br>

### Suspensión study drug

<br>

#### Global

<br>

```{r}
suspension<-data%>%
  select(id, Event=redcap_event_name,
         Discontinuation=suspension_anifro,
         `Lack of efficacy`=motivo_suspension___1,
         `Side effect`=motivo_suspension___2,
         `Non-adherence`=motivo_suspension___3,
         Other=motivo_suspension___4)

```

```{r}
suspension_global<-suspension %>%
  # Filtrar para eliminar filas donde Event sea "Baseline"
  filter(Event != "Baseline") %>%
  # Agrupar por id
  group_by(id) %>%
  # Crear nuevas columnas sumando valores de los tiempos 3 months y 6 months
  summarise(
    Discontinuation = sum(Discontinuation[Event %in% c("3 months", "6 months")], na.rm = TRUE),
    `Lack of efficacy` = sum(`Lack of efficacy`[Event %in% c("3 months", "6 months")], na.rm = TRUE),
    `Side effect` = sum(`Side effect`[Event %in% c("3 months", "6 months")], na.rm = TRUE),
    `Non-adherence` = sum(`Non-adherence`[Event %in% c("3 months", "6 months")], na.rm = TRUE),
    Other = sum(Other[Event %in% c("3 months", "6 months")], na.rm = TRUE)
  )
```

```{r,fig.dim=c(6,6)}
# Crear tabla resumida con las frecuencias y porcentajes
discontinuation_summary <- suspension_global %>%
  mutate(Discontinuation = ifelse(Discontinuation == 1, "Yes", "No")) %>%
  count(Discontinuation) %>%
  mutate(Percentage = n / sum(n) * 100)

# Crear el gráfico tipo quesito
ggplot(discontinuation_summary, aes(x = "", y = n, fill = Discontinuation)) +
  geom_bar(stat = "identity", width = 1, color = "white") +
  coord_polar("y", start = 0) +
  geom_label(aes(label = paste0("N=", n, "\n", round(Percentage, 1), "%")),
            position = position_stack(vjust = 0.5), size = 4,show.legend = F) +
  scale_fill_manual(values = c("Yes" = "brown2", "No" = "steelblue")) +
  labs(title = "Global Treatment Discontinuation", fill = "Discontinuation") +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5, size = 16))
```

<br>

#### A los 3 meses


```{r}
suspension_3m<-suspension %>%
  filter(Event == "3 months") %>%
  mutate(across(everything(), ~replace_na(., 0)))
```

```{r,fig.dim=c(6,6)}
# Crear tabla resumida con las frecuencias y porcentajes
discontinuation_summary <- suspension_3m %>%
  mutate(Discontinuation = ifelse(Discontinuation == 1, "Yes", "No")) %>%
  count(Discontinuation) %>%
  mutate(Percentage = n / sum(n) * 100)

# Crear el gráfico tipo quesito
ggplot(discontinuation_summary, aes(x = "", y = n, fill = Discontinuation)) +
  geom_bar(stat = "identity", width = 1, color = "white") +
  coord_polar("y", start = 0) +
  geom_label(aes(label = paste0("N=", n, "\n", round(Percentage, 1), "%")),
            position = position_stack(vjust = 0.5), size = 4,show.legend = F) +
  scale_fill_manual(values = c("Yes" = "brown2", "No" = "steelblue")) +
  labs(title = "Treatment Discontinuation at 3 months", fill = "Discontinuation") +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5, size = 16))


```


<br>

#### A los 6 meses

<br>

```{r}
suspension_6m<-suspension %>%
  filter(Event == "6 months") %>%
  mutate(across(everything(), ~replace_na(., 0)))
```

```{r,fig.dim=c(6,6)}
# Crear tabla resumida con las frecuencias y porcentajes
discontinuation_summary <- suspension_6m %>%
  mutate(Discontinuation = ifelse(Discontinuation == 1, "Yes", "No")) %>%
  count(Discontinuation) %>%
  mutate(Percentage = n / sum(n) * 100)

# Crear el gráfico tipo quesito
ggplot(discontinuation_summary, aes(x = "", y = n, fill = Discontinuation)) +
  geom_bar(stat = "identity", width = 1, color = "white") +
  coord_polar("y", start = 0) +
  geom_label(aes(label = paste0("N=", n, "\n", round(Percentage, 1), "%")),
            position = position_stack(vjust = 0.5), size = 4,show.legend = F) +
  scale_fill_manual(values = c("Yes" = "brown2", "No" = "steelblue")) +
  labs(title = "Treatment Discontinuation at 6 months", fill = "Discontinuation") +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5, size = 16))


```


<br>

#### Motivos de la suspensión global

<br>

```{r,fig.dim=c(6,6)}

# Filtrar los casos donde Discontinuation == 1
reasons_summary <- suspension_global %>%
  filter(Discontinuation == 1) %>%
  summarise(
    `Lack of efficacy` = sum(`Lack of efficacy`, na.rm = TRUE),
    `Side effect` = sum(`Side effect`, na.rm = TRUE),
    `Non-adherence` = sum(`Non-adherence`, na.rm = TRUE),
    Other = sum(Other, na.rm = TRUE)
  ) %>%
  pivot_longer(cols = everything(), names_to = "Reason", values_to = "Count") %>%
  filter(Count > 0) %>%  # Eliminar categorías con Count == 0
  mutate(Percentage = Count / sum(Count) * 100) 

# Crear el gráfico de las razones
ggplot(reasons_summary, aes(x = "", y = Count, fill = Reason)) +
  geom_bar(stat = "identity", width = 1, color = "white") +
  coord_polar("y", start = 0) +
  geom_label(aes(
    label = paste0("N=", Count, "\n", round(Percentage, 1), "%")),
  position = position_stack(vjust = 0.5), 
  size = 4, 
  show.legend = FALSE) +  
  scale_fill_manual(values = c("Lack of efficacy" = "steelblue", 
                               "Side effect" = "tomato", 
                               "Other" = "purple")) +
  labs(title = "Reasons for Treatment Discontinuation", fill = "Reason") +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5, size = 16))


```

<br>

### Infecciones Covid o Herpeszoster

<br>

```{r}
infeccion<-data%>%
  select(id, infec_covid19_con_anifro,infeccion_herpeszoster)%>%
  na.omit(.)
```

```{r,fig.dim=c(6.6)}

# Crear una columna categórica que clasifique las infecciones
infection_status <- infeccion %>%
  mutate(Infection = case_when(
    infec_covid19_con_anifro == 1 ~ "COVID-19", 
    infeccion_herpeszoster == 1 ~ "Herpes Zoster", 
    infec_covid19_con_anifro == 0 & infeccion_herpeszoster == 0 ~ "No infection",
    TRUE ~ "No data"
  )) %>%
  count(Infection) %>%
  mutate(Percentage = n / sum(n) * 100)

# Crear el gráfico de pie
ggplot(infection_status, aes(x = "", y = n, fill = Infection)) +
  geom_bar(stat = "identity", width = 1, color = "white") +
  coord_polar("y", start = 0) +
  geom_label_repel(aes(
    label = paste0("N=", n, "\n", round(Percentage, 1), "%")),
    position = position_stack(vjust = 0.5), 
    size = 4, 
    show.legend = FALSE) +
  scale_fill_manual(values = c("COVID-19" = "steelblue", 
                               "Herpes Zoster" = "tomato", 
                               "No infection" = "chartreuse3")) +
  labs(title = "Infection Status of Patients", fill = "Infection Type") +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5, size = 16))

```
